#book-refactoring

## 第2章 リファクタリングの原則

### リファクタリングの定義

- 名詞
  - 外部から見たときの振る舞いを保ちつつ、理解や修正が簡単になるように、ソフトウェアの内部構造を変化させること
- 動詞
  - 一連のリファクタリングを適用して、外部から見た振る舞いの変更なしに、ソフトウェアを再構築すること
- あくまでソフトウェアを理解しやすく、変更を容易にするために行う
- ソフトウェアの外的振る舞いを保つことで、変更があったことに気づかない

#### 2つの帽子

- 機能追加とリファクタリングを区別する
- 常にどちらの帽子をかぶっているのか意識する

### リファクタリングを行う理由

- 設計の改善
- ソフトウェアが理解しやすくなる
- バグを見つけ出す
  - KentBeck「偉大なプログラマではなく、偉大な習慣を身に付けたプログラマ」
- より速くプログラミングできる
  - ラピッドな開発には優れた設計が不可欠である

### いつリファクタリングをすべきか

- 時間を設けて行うようなものではない
- 作業の中で要求が自然に発生するもの
- 3度目の法則
  - 3度目に似たようなことをしていると気付いたら
- 機能追加の時に行う
  - リファクタリングで機能追加を容易にする
- バグフィックスの時に行う
  - コードを理解するため
  - バグレポートをリファクタリングが必要な兆候とも考えられる
- コードレビューの時に行う
  - アイデアの結果を「実際に見る」ことができる
  - 少人数で行うべき
    - XPにおけるペアプロ

### 管理者を説得するには

- 品質を気にしている管理者
  - 品質の側面を強調する
  - レビューの過程でリファクタライングを採用する
  - レビューはバグを減らし、開発速度を上げるという多くの研究がある
- スケジュールを気にしている管理者
  - 黙ってやる
  - 最も速い方法がリファクタリング

### リファクタリングの問題点

- データベース
  - データの移行が必ずつきまとう
  - オブジェクトモデルとデータベースモデルの間に分離する層を用意する
  - 中間層は後から用意しても良い
- インターフェースの変更
  - 呼び出し元がすべて特定できるような場合大きな問題とはならない
  - 問題は公布済みインターフェース
  - 一定期間は両方のインターフェースを維持する
    - 古い実装で新しい実装を呼ぶようにする
    - Javaは `@Deprecated` が活用できる
  - 例外はパッケージレベルでの例外スーパークラスを用意すると柔軟になる
    - 公開メソッドではその例外をthrows宣言に使う
- リファクタリングしにくい設計
  - 設計の候補を並べて手間を考慮する
  - 容易に思われる場合はあまり検討せず単純な方法を採用
  - 困難な場合は時間をかけて検討する
- リファクタリングを避けるとき
  - 変更するより書き直したほうが早い場合
    - コードがほぼ正しく動作する水準に達している必要がある
     - カプセル化して、部分的にリファクタリングするという妥協案
      - レガシーシステムが重要な位置を占める場合には魅力的
  - 期間が迫っている場合
    - 生産性の向上が締め切り後に見られても遅い
    - 未着手のリファクタリングは借金であり、利子がある
    - リファクタリングを避けてはいけない
      - 時間が足りなくなるのは、リファクタリングが必要であるということ

### リファクタリングと設計

- リファクタリングを行う場合でも事前設計はある程度必要
- 設計が唯一無二の完璧な解決策を見出すものではなくなる
- 設計の簡素化
  - シンプルな解決策を柔軟なものにリファクタリングする
- 柔軟で複雑な設計というものは、ほとんどの場合、必要とされない
